import java.io.*;
import java.util.*;

class Main {
    static class Edge {
        int to;
        long w;
        Edge(int t, long w) { this.to = t; this.w = w; }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        List<Edge>[] top3 = new ArrayList[N + 1];
        for (int i = 1; i <= N; i++) top3[i] = new ArrayList<>();

        int[][] inputEdges = new int[M][2];
        long[] weights = new long[M];

        for (int i = 0; i < M; i++) {
            st = new StringTokenizer(br.readLine());
            int u = Integer.parseInt(st.nextToken());
            int v = Integer.parseInt(st.nextToken());
            long w = Long.parseLong(st.nextToken());
            
            top3[u].add(new Edge(v, w));
            top3[v].add(new Edge(u, w));
            inputEdges[i][0] = u;
            inputEdges[i][1] = v;
            weights[i] = w;
        }

        // 각 노드별 상위 3개 간선만 유지 (O(N log N))
        for (int i = 1; i <= N; i++) {
            top3[i].sort((e1, e2) -> Long.compare(e2.w, e1.w));
            if (top3[i].size() > 3) {
                top3[i] = new ArrayList<>(top3[i].subList(0, 3));
            }
        }

        long ans = 0;

        // 모든 간선을 '가운데' 시너지(P2-P3)로 가정하고 탐색
        for (int i = 0; i < M; i++) {
            int u = inputEdges[i][0];
            int v = inputEdges[i][1];
            long uvW = weights[i];

            // P1-P2 시너지(ea)와 P3-P4 시너지(ed)를 찾음
            // 만약 연결된 시너지가 없다면 0으로 계산됨
            
            // 1. a-u-v-d 구조
            long bestA = 0;
            for (Edge ea : top3[u]) {
                if (ea.to == v) continue;
                
                long bestD = 0;
                for (Edge ed : top3[v]) {
                    // a, u, v, d가 모두 달라야 함
                    if (ed.to == u || ed.to == ea.to) continue;
                    bestD = Math.max(bestD, ed.w);
                }
                // ed를 못 찾아도 ea.w + uvW 조합은 가능함
                ans = Math.max(ans, uvW + ea.w + bestD);
            }
            
            // 2. 혹시 u-v만 있고 양옆에 아무 시너지가 없는 경우도 고려
            ans = Math.max(ans, uvW);
        }

        // 추가 케이스: 시너지가 2개인 경우 (a-b와 c-d가 멀리 떨어져 있을 때)
        // 이 부분은 간선 전체 정렬 후 상위 2개만 확인해도 충분함
        Arrays.sort(weights);
        if (M >= 2) {
            // N >= 4 이므로 가장 큰 두 간선을 어떻게 배치해도 4명 구성 가능
            ans = Math.max(ans, weights[M-1] + weights[M-2]);
        }

        System.out.println(ans);
    }
}